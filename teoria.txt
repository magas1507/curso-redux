***REDUX: Libreria nos ayuda a manejar de mejor manera 
el estado de nuestra aplicaci√≥n. Para usarlos se necesita:

    D√≥nde almacenar: Store
    C√≥mo acceder: Mediantes m√©todos, ejempo: selectores.
    C√≥mo actualizar: Disparadores, actions √≥ reducers.
    
    Consta de tres principios:

      -√önica fuente de verdad (store)
      -El estado es de solo lectura, no modificarlo directamente sino 
      atraves de actions.
      -Los cambios deben realizarse atrav√©s de funciones puras (reducers)
    
    Funciones Puras caractesristicas:
      Valor de entrada cambia si la entrada cambia.
      -Misma entrada, misma salida.
      -No tener l√≥gica s√≠ncrona



***¬øQu√© es Redux? -> 
  Es una librer√≠a que nos ayuda a manejar el estado de nuestra aplicaci√≥n.

  *Necesitamos 3 cosas:

    D√≥nde almancenar la informaci√≥n
    C√≥mo acceder a ella
    C√≥mo actualizarla
    
  *Redux est√° basado en 3 principios:

    -Hay solo una √∫nica fuente de verdad (store) => La diferencia entre 
      State y Store es que 
      -State es un objeto de tipo ‚Äòclave: valor‚Äô (aunque puede ser de otros 
        tipos). 
      -El Store contiene al State y a otras cosas.
      -El estado es de solo lectura (solo se actualiza con actions). 
        No debemos modificarlo directamente.
      -Los cambios deben realizarse a trav√©s de funciones puras (reducers).

  *Funciones puras

    -Valor retornado cambia si la entrada cambia.
    -Misma entrada, misma salida.
    -Sin efectos colaterales

  *Entrada: x -> Funci√≥n Pura: f -> Salida: F(x)

  *Reducers

    -Calcular el nuevo estado basado en los par√°metros (state, action).
    -No modificar el estado directamente.
    -No tener l√≥gica as√≠ncrona.

***CICLO DE VIDA REDUX
    -Despacho de una acci√≥n: Un evento de UI, una respuesta de red o 
      cualquier otra fuente despacha una acci√≥n, que es un objeto de 
      JavaScript simple que describe el cambio a realizar.

    -Actualizaci√≥n del almac√©n: El almac√©n de Redux recibe la acci√≥n 
      despachada y la pasa a la funci√≥n reductora. El reductor calcula 
      el nuevo estado en base al estado actual y la acci√≥n.

    -Actualizaci√≥n de los componentes: El almac√©n emite un evento de 
      cambio, lo que hace que los componentes que est√°n suscritos al 
      almac√©n vuelvan a renderizarse. El nuevo estado est√° disponible 
      en el almac√©n y puede ser utilizado por los componentes para 
      renderizar la UI actualizada.

    -El usuario interact√∫a con la UI actualizada: El usuario interact√∫a 
      con la UI actualizada, potencialmente provocando otro despacho de 
      acci√≥n. Esto comienza el ciclo nuevamente.

    -Nota: Es importante recordar que el estado debe tratarse como 
      inmutable y no modificarse directamente. Se deben crear nuevos 
      estados para reflejar los cambios.

      1)state define UI
      2)en la UI el usuario dispara una acci√≥n
      3)la acci√≥n es mandada al reducer
      4)el reducer actualiza el store
      5)el store contiene al state
     
      6)volvemos al paso 1
 ***Diferencias entre Redux y Context****

    > ‚Äú*Cuando un sistema es opaco y no determinista, es d√≠f√≠cil reproducir
     errores o agregar nuevas caracter√≠sticas.‚Äù
    **~Redux Docs***
    > 

    En React el paso de datos entre padres e hijos se realiza a trav√©s de 
    las *props*. Probablemente para un componente padre que tiene un solo 
    nivel de hijos este paso de datos se realice de forma sencilla, pero, 
    
    ¬øQu√© pasa si aumentan los niveles de profundidad y necesito pasarle 
    datos a un hijo en el nivel muy profundo? ü§î 
    
    Debemos pasar los *props* entre componentes hijos para que pueda 
    llegar a su destino provocando que existan componentes con *props* 
    que probablemente no necesitan.

    Este problema se le conoce como ***prop drilling*** y ocasiona que el estado se vuelva mucho mas d√≠ficil de mantener.

    Debido a este problema entonces nace Redux ya que facilita el manejo 
    del estado y hace que √©ste sea mas predecible y traceable. 
    Sin embargo, como otra alternativa para solucionar este problema 
    tenemos Context API de React pero antes de hablar de sus diferencias 
    echemos un vistazo general a este concepto.

    **Context API**

      -Es una herramienta que nos permite pasar datos de componentes padre 
      a hijos sin tener que pasar por todos los componentes hijos ubicados 
      en los distintos niveles. 
      Fue dise√±ado para compartir los datos que son considerados ‚ÄúGlobales‚Äù.

      -Podemos usar esta herramienta para el uso de datos que no cambian 
      constantemente a lo largo de nuestra aplicaci√≥n: Modo (Oscuro o Claro),
       Usuario autenticado o Idioma (Ingl√©s o Espa√±ol).

      -Disponible a partir de la versi√≥n **16.3** de React

    **Redux vs. Context API**
    Diferencias entre Redux y Context

  Redux facilita el manejo del estado y lo hace mas predecible 
  y rastreable.

  ‚ÄìReact propone Context API:

    *Proporciona una forma de pasar datos de los componentes padres a los 
    componentes hijos mediante el arbol de componentes sin pasar manualmente
    por todos los niveles.
    *Est√° dise√±ado para compartir los datos que pueden ser considerados 
    globales.
    *Podemos usarlo cuando vamos a hacer uso de datos que generalmente 
    no cambiar√°n mucho a lo largo del uso de la app. Como el modo, 
    tema, idioma o usuario autentificado.
    
    *Se puede usar a partir de la versi√≥n 16.3 de React.
‚ÄìRedux vs Context API

  *Depuraci√≥n: Con el depurador de Redux podemos ‚Äúviajar en el tiempo‚Äù en 
  cambio Context API al tener conectado todo al mismo provider es m√°s 
  dificil de depurar.
  
  *Bundle Size: Context viene integrado y no necesitas librerias adicionales.
   Con redux, si, por lo que crece el bundle size de la app.
  
  *Middlewares: Redux tiene una forma sencilla de extender la funcionabilidad 
  de nuestros triggers o distpachers que nos permite agregar middlewares que
  atajen la data en cierto punto antes de que llegue a cambiar el estado.
  
  *Curva de aprendizaje: Context API tiene una curva de aprendizaje m√°s 
  ligera. Con redux tenemos que aprender un nuevo paradigma, 
  entender el ciclo de vida de los datos y aprender sobre la sintaxis.
  
  *Rendering: Redux nos permite prevenir renders innecesarios.


  ***8-integraci√≥n de Redux-
  1) creammos la carpeta actions
  2) Creamos los types: de esta forma evitamos errores
  3) luego en el index
      -creamos nuestros actions creator: es una funci√≥n que retorna un 
        action, es decir, un objeto que describe el cambio que va a pasar 
  4) setPokemons:  esta es una funci√≥n y va a recibir nuestro payload.

        -Pero ¬øcu√°l va a ser nuestro payload? Los nuevos pokemones.
          le puedes poner pokemons y enviar un objeto. 
          -Por simplicidad, vamos a llamarle ac√° payload 

  5) Ahora en App.js conectamos con Redux importando esta propiedad de 
    Redux llamada connect

      -connect 
  6) Vamos a tener dos variables.

      - mapStateToProps: es una funci√≥n recibe nuestro estado y retorna un 
        objeto cuyas propiedades van a ser enviadas a las props del 
        componente que se est√° conectado a redux.
      
      - mapDispatchToProps es una funci√≥n que recibe el dispatcher de redux 
        y retorna un objeto que ser√° mapedo a las propiedades con los action
        creators
          En setPokemonsActions nos falta una cosa, y es en d√≥nde estan los
          Valores que le vamos a pasar? 
          D√≥nde est√° la lista que estamos obteniendo de la API,
          - Por ende vamos agregar un par√°metro que sea Value
          -Retornamos ese dispatch, le vamos a pasar Value.
          -Recuerda que llegara como payload al Action Creator
    7)conectamos MapStateToProps y luego MapStateDispatchToProps,      
    8) Ahora d√≥nde est√° nuestro Reducers?
    9) Creamos en src una carpeta reducers      
    10) Tendremos nuestro archivo llamado pokemons
        -Donde primero vamos a necesitar nuestro initialState
        -Nuestro initialState es recomendable que sea un objeto clave valor
        -Este pokemon lo sacabamos del estado, desde la propiedad pokemon
        -dejando el initialState como un arreglo vacio
        -Ahora necesitamos el reducer que es una funci√≥n puras
        -Exportamos nuestra funci√≥n pokemonsReducer
        -pokemonsReducer recibe el estado actual y el action, que es el 
          cambio que queremos realizar (es recomendado usar switch)
        -Nuestro primer caso es el setPokemons, as√≠ que immportamos ese 
          type
        -retornamos nuestro nuevo estado, usando el concepto de inmutabilidad
        -Cuando no conocemos el action type que nos est√° llegando usamos 
          simplemente el estado actual, colocandolo por defecto
    11) Ahora si, integramos redux a nuestro main.jsx o index.js
        -importando nuestro pokemonsReducer
        -importamos tambien el provider de Redux 
        -y el legacy_createStore

    12) creamos el store, utilizamos este m√©todo y aqu√≠ dice que le debemos pasar el reducer.
        - Ya sabemos que buscamos nuestro pokemonsReducer
    
    13) Envolvemos el app en el provider que recibe como prop el Store 

    14) pasamos las props al App(pokemos, setPokemons).         


    