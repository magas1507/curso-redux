***REDUX: Libreria nos ayuda a manejar de mejor manera 
el estado de nuestra aplicaci√≥n. Para usarlos se necesita:

    D√≥nde almacenar: Store
    C√≥mo acceder: Mediantes m√©todos, ejempo: selectores.
    C√≥mo actualizar: Disparadores, actions √≥ reducers.
    
    Consta de tres principios:

      -√önica fuente de verdad (store)
      -El estado es de solo lectura, no modificarlo directamente sino 
      atraves de actions.
      -Los cambios deben realizarse atrav√©s de funciones puras (reducers)
    
    Funciones Puras caractesristicas:
      Valor de entrada cambia si la entrada cambia.
      -Misma entrada, misma salida.
      -No tener l√≥gica s√≠ncrona



***¬øQu√© es Redux? -> 
  Es una librer√≠a que nos ayuda a manejar el estado de nuestra aplicaci√≥n.

  *Necesitamos 3 cosas:

    D√≥nde almancenar la informaci√≥n
    C√≥mo acceder a ella
    C√≥mo actualizarla
    
  *Redux est√° basado en 3 principios:

    -Hay solo una √∫nica fuente de verdad (store) => La diferencia entre 
      State y Store es que 
      -State es un objeto de tipo ‚Äòclave: valor‚Äô (aunque puede ser de otros 
        tipos). 
      -El Store contiene al State y a otras cosas.
      -El estado es de solo lectura (solo se actualiza con actions). 
        No debemos modificarlo directamente.
      -Los cambios deben realizarse a trav√©s de funciones puras (reducers).

  *Funciones puras

    -Valor retornado cambia si la entrada cambia.
    -Misma entrada, misma salida.
    -Sin efectos colaterales

  *Entrada: x -> Funci√≥n Pura: f -> Salida: F(x)

  *Reducers

    -Calcular el nuevo estado basado en los par√°metros (state, action).
    -No modificar el estado directamente.
    -No tener l√≥gica as√≠ncrona.

***CICLO DE VIDA REDUX
    -Despacho de una acci√≥n: Un evento de UI, una respuesta de red o 
      cualquier otra fuente despacha una acci√≥n, que es un objeto de 
      JavaScript simple que describe el cambio a realizar.

    -Actualizaci√≥n del almac√©n: El almac√©n de Redux recibe la acci√≥n 
      despachada y la pasa a la funci√≥n reductora. El reductor calcula 
      el nuevo estado en base al estado actual y la acci√≥n.

    -Actualizaci√≥n de los componentes: El almac√©n emite un evento de 
      cambio, lo que hace que los componentes que est√°n suscritos al 
      almac√©n vuelvan a renderizarse. El nuevo estado est√° disponible 
      en el almac√©n y puede ser utilizado por los componentes para 
      renderizar la UI actualizada.

    -El usuario interact√∫a con la UI actualizada: El usuario interact√∫a 
      con la UI actualizada, potencialmente provocando otro despacho de 
      acci√≥n. Esto comienza el ciclo nuevamente.

    -Nota: Es importante recordar que el estado debe tratarse como 
      inmutable y no modificarse directamente. Se deben crear nuevos 
      estados para reflejar los cambios.

      1)state define UI
      2)en la UI el usuario dispara una acci√≥n
      3)la acci√≥n es mandada al reducer
      4)el reducer actualiza el store
      5)el store contiene al state
     
      6)volvemos al paso 1
 ***Diferencias entre Redux y Context****

    > ‚Äú*Cuando un sistema es opaco y no determinista, es d√≠f√≠cil reproducir
     errores o agregar nuevas caracter√≠sticas.‚Äù
    **~Redux Docs***
    > 

    En React el paso de datos entre padres e hijos se realiza a trav√©s de 
    las *props*. Probablemente para un componente padre que tiene un solo 
    nivel de hijos este paso de datos se realice de forma sencilla, pero, 
    
    ¬øQu√© pasa si aumentan los niveles de profundidad y necesito pasarle 
    datos a un hijo en el nivel muy profundo? ü§î 
    
    Debemos pasar los *props* entre componentes hijos para que pueda 
    llegar a su destino provocando que existan componentes con *props* 
    que probablemente no necesitan.

    Este problema se le conoce como ***prop drilling*** y ocasiona que el estado se vuelva mucho mas d√≠ficil de mantener.

    Debido a este problema entonces nace Redux ya que facilita el manejo 
    del estado y hace que √©ste sea mas predecible y traceable. 
    Sin embargo, como otra alternativa para solucionar este problema 
    tenemos Context API de React pero antes de hablar de sus diferencias 
    echemos un vistazo general a este concepto.

    **Context API**

      -Es una herramienta que nos permite pasar datos de componentes padre 
      a hijos sin tener que pasar por todos los componentes hijos ubicados 
      en los distintos niveles. 
      Fue dise√±ado para compartir los datos que son considerados ‚ÄúGlobales‚Äù.

      -Podemos usar esta herramienta para el uso de datos que no cambian 
      constantemente a lo largo de nuestra aplicaci√≥n: Modo (Oscuro o Claro),
       Usuario autenticado o Idioma (Ingl√©s o Espa√±ol).

      -Disponible a partir de la versi√≥n **16.3** de React

    **Redux vs. Context API**
    Diferencias entre Redux y Context

  Redux facilita el manejo del estado y lo hace mas predecible 
  y rastreable.

  ‚ÄìReact propone Context API:

    *Proporciona una forma de pasar datos de los componentes padres a los 
    componentes hijos mediante el arbol de componentes sin pasar manualmente
    por todos los niveles.
    *Est√° dise√±ado para compartir los datos que pueden ser considerados 
    globales.
    *Podemos usarlo cuando vamos a hacer uso de datos que generalmente 
    no cambiar√°n mucho a lo largo del uso de la app. Como el modo, 
    tema, idioma o usuario autentificado.
    
    *Se puede usar a partir de la versi√≥n 16.3 de React.
‚ÄìRedux vs Context API

  *Depuraci√≥n: Con el depurador de Redux podemos ‚Äúviajar en el tiempo‚Äù en 
  cambio Context API al tener conectado todo al mismo provider es m√°s 
  dificil de depurar.
  
  *Bundle Size: Context viene integrado y no necesitas librerias adicionales.
   Con redux, si, por lo que crece el bundle size de la app.
  
  *Middlewares: Redux tiene una forma sencilla de extender la funcionabilidad 
  de nuestros triggers o distpachers que nos permite agregar middlewares que
  atajen la data en cierto punto antes de que llegue a cambiar el estado.
  
  *Curva de aprendizaje: Context API tiene una curva de aprendizaje m√°s 
  ligera. Con redux tenemos que aprender un nuevo paradigma, 
  entender el ciclo de vida de los datos y aprender sobre la sintaxis.
  
  *Rendering: Redux nos permite prevenir renders innecesarios.
  
  *"connet":connect" es una funci√≥n proporcionada por la biblioteca 
  "react-redux" que se utiliza para conectar componentes de React a un 
  store de Redux. 

    -puedes usar la funci√≥n "connect" para conectar tus componentes de 
    React al estado almacenado en el store de Redux. 
    
    -Esto permite que los componentes accedan al estado global y tambi√©n 
    les proporciona la capacidad de despachar acciones para modificar ese
     estado.

    -La funci√≥n "connect" toma como argumentos dos funciones: 
      -"mapStateToProps" y 
      -"mapDispatchToProps":

  ***8-integraci√≥n de Redux-
  1) creammos la carpeta actions
  2) Creamos los types: de esta forma evitamos errores
  3) luego en el index
      -creamos nuestros actions creator: es una funci√≥n que retorna un 
        action, es decir, un objeto que describe el cambio que va a pasar 
  4) setPokemons:  esta es una funci√≥n y va a recibir nuestro payload.

        -Pero ¬øcu√°l va a ser nuestro payload? Los nuevos pokemones.
          le puedes poner pokemons y enviar un objeto. 
          -Por simplicidad, vamos a llamarle ac√° payload 

  5) Ahora en App.js conectamos con Redux importando esta propiedad de 
    Redux llamada connect

      -connect 
  6) Vamos a tener dos variables.

      - mapStateToProps: es una funci√≥n recibe nuestro estado y retorna un 
        objeto cuyas propiedades van a ser enviadas a las props del 
        componente que se est√° conectado a redux.
      
      - mapDispatchToProps es una funci√≥n que recibe el dispatcher de redux 
        y retorna un objeto que ser√° mapedo a las propiedades con los action
        creators
          En setPokemonsActions nos falta una cosa, y es en d√≥nde estan los
          Valores que le vamos a pasar? 
          D√≥nde est√° la lista que estamos obteniendo de la API,
          - Por ende vamos agregar un par√°metro que sea Value
          -Retornamos ese dispatch, le vamos a pasar Value.
          -Recuerda que llegara como payload al Action Creator
    7)conectamos MapStateToProps y luego MapStateDispatchToProps,      
    8) Ahora d√≥nde est√° nuestro Reducers?
    9) Creamos en src una carpeta reducers      
    10) Tendremos nuestro archivo llamado pokemons
        -Donde primero vamos a necesitar nuestro initialState
        -Nuestro initialState es recomendable que sea un objeto clave valor
        -Este pokemon lo sacabamos del estado, desde la propiedad pokemon
        -dejando el initialState como un arreglo vacio
        -Ahora necesitamos el reducer que es una funci√≥n puras
        -Exportamos nuestra funci√≥n pokemonsReducer
        -pokemonsReducer recibe el estado actual y el action, que es el 
          cambio que queremos realizar (es recomendado usar switch)
        -Nuestro primer caso es el setPokemons, as√≠ que immportamos ese 
          type
        -retornamos nuestro nuevo estado, usando el concepto de inmutabilidad
        -Cuando no conocemos el action type que nos est√° llegando usamos 
          simplemente el estado actual, colocandolo por defecto
    11) Ahora si, integramos redux a nuestro main.jsx o index.js
        -importando nuestro pokemonsReducer
        -importamos tambien el provider de Redux 
        -y el legacy_createStore

    12) creamos el store, utilizamos este m√©todo y aqu√≠ dice que le debemos pasar el reducer.
        - Ya sabemos que buscamos nuestro pokemonsReducer
    
    13) Envolvemos el app en el provider que recibe como prop el Store 

    14) pasamos las props al App(pokemos, setPokemons).         


**9.-Hooks vs. Connect

  *useSelector vs Connect

    -Boilerplate: Nos ahorramos codigo usando hooks.
    
    -Separaci√≥n de responsabilidades: Connect el metodo crea un componente 
    de orden mayor que es quien renderiza el componente y le pasa el 
    estado y action a trav√©s de los props.
    
    -Testing: Es m√°s f√°cil hacer testing con connect ya que recibe el 
    estado por los props y solo se env√≠an props, en cambio con los hooks
    tendremos que conectar el componente a redux antes de testear.

    Redux recomienda usar su Hooks API.

    Hooks API

    *useSelector: nos permite extraer la data del estado a traves de una 
    funcion selectora (que debe ser pura), es equivalente al 
    mapstatetoprops, solo que el valor se guarda en una variable. 
    
      -El selector sera llamado cada que se haga distpatch de una acci√≥n 
      para evaluar si se renderiza de nuevo un componente.
    
    *useDispatch: nos retorna una referencia del dispatcher del store de 
    redux el cual usamos para disparar acciones.

  * Redux DevTool

    Redux DevTools es una herramienta de desarrollo para aplicaciones 
    Redux. 
    
    -Ofrece varias funcionalidades √∫tiles para los desarrolladores, como:

    -Monitorizaci√≥n en tiempo real del estado de la aplicaci√≥n: 
      permite ver c√≥mo cambia el estado de la aplicaci√≥n en funci√≥n de 
      las acciones dispatches y las transformaciones de los reducers.

    -Debugging: permite hacer un seguimiento de las acciones y ver c√≥mo 
      cambian los valores del estado.

    -Reproducci√≥n: permite retroceder y avanzar en el tiempo para ver 
      c√≥mo el estado de la aplicaci√≥n cambi√≥ a lo largo del tiempo.

    -Persistencia: permite guardar y cargar el estado de la aplicaci√≥n 
      para continuar el desarrollo y debugging despu√©s de una recarga 
      de la p√°gina.

    -Integraci√≥n con la l√≠nea de comandos: permite integrarse con otras 
      herramientas de desarrollo y scripts.

    Para habilitarlo agreamos la siguiente linea al crear el store:

      const store = createStore(
        pokemonsReducer,
        window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()
      );

      forma actual:

      import { configureStore } from'@reduxjs/toolkit';
      import pokemonReducer from'./features/pokemonSlice';
      import { logActions } from'../middlewares';


      export const store = configureStore({
        reducer: {
          pokemon: pokemonReducer,
        },
        middleware: (getDefaultMiddleware) => getDefaultMiddleware().concat(logActions),
      })

  **Middlewares:
      Es una pieza de c√≥digo que se ejecuta cuando X recibe un request y 
      ese mismo X da respuesta al request.

      Ayuda a los desarrolladores a dise√±ar aplicaciones con mayor 
      eficiencia. 
      
      Adem√°s, act√∫a como hilo conductor entre las aplicaciones, 
      los datos y los usuarios.

        Los podemos usar para:

        Hacer logs de errores

        Hacer fetch de data

        Depurar nuestra aplicaci√≥n

        Tambi√©n podemos customizar nuestra data con applyMiddleware

      *Currying es una t√©cnica de programaci√≥n funcional que permite 
      transformar una funci√≥n que toma m√∫ltiples argumentos en una 
      secuencia de funciones que toman un solo argumento cada una.

        El objetivo de currying es hacer que las funciones sean m√°s 
        reutilizables y componibles, permitiendo a los desarrolladores 
        crear funciones m√°s espec√≠ficas a partir de funciones m√°s generales.


      *Currificaci√≥n es una transformaci√≥n que hace que f(a, b, c) sea 
      invocable como f(a)(b)(c). 
      
        -Las implementaciones de JavaScript generalmente mantienen la 
        funci√≥n invocable normalmente y devuelven el parcial si el 
        conteo de argumentos no es suficiente.

        -La currificaci√≥n nos permite obtener parciales f√°cilmente. 
        Como hemos visto en el ejemplo de registro, despu√©s de aplicar 
        currificaci√≥n a la funci√≥n universal de tres argumentos 
        log(fecha, importancia, mensaje) 
        nos da parciales cuando se llama con un argumento (como log(fecha)) 
        o dos argumentos (como log(fecha, importancia)).      

***Redux Thunk
    Es un Middleware que extiende las capacidades del store (enhancer), nos 
    permite realizar acciones as√≠ncronas en nuestros actions creators que 
    por defecto no podemos hacer
    Thunk es un concepto de programaci√≥n donde se utiliza una funci√≥n intermedia para retrasar la evaluaci√≥n o ejecuci√≥n de una operaci√≥n, como puede ser la petici√≥n de una data a una API y dem√°s acciones
    para este caso en particular separaremos responsabilidades, delegando la petici√≥n a la API a nuestro action creator y no a el componente como se venia trabajando

    Instalaci√≥n

      npm install redux-thunk

    Integraci√≥n
      simplemente debemos importarlo y a√±adirlo a nuestra composici√≥n de 
      middlewares
      src/index.js:

    import thunk from 'redux-thunk'; 
    .....
    ....
    ...
    .


    const composeEnhancers = compose( 
      applyMiddleware(thunk, logger)  // **
    )

    const store = createStore(
        pokemonsReducer,
        composeEnhancers    
      )

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(
      <React.StrictMode>
        <Provider store={store}>
          <App />
        </Provider>
      </React.StrictMode>
    )
    si estamos haciendo uso de la herramienta Redux DevTools debemos hacer pasos adicionales
    src/index.js:

    import thunk from 'redux-thunk';
    .....
    ...
    .


    const composeAlt = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE_ || compose 

    const composeEnhancers = composeAlt( 
      applyMiddleware(thunk, logger) 
    )

    const store = createStore(
        pokemonsReducer,
        composeEnhancers    
      )

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(
      <React.StrictMode>
        <Provider store={store}>
          <App />
        </Provider>
      </React.StrictMode>
    )
    Creaci√≥n action creator
      una vez integrado procederemos a crear nuestro action creator que 
      ser√° una funci√≥n la cual contendr√° la petici√≥n a la API que ven√≠amos
      trabajando, esa funci√≥n har√° la petici√≥n a la API, obtendr√° su 
      respuesta y devolver√° otra funci√≥n la cual recibe como par√°metro el 
      dispatch para poder disparar acciones, este dispatch recibir√° como 
      par√°metro la acci√≥n setPokemons que a su vez recibir√° como par√°metro
      la respuesta de la petici√≥n a la API
    
    src/actions/index.js:

    export const getPokemonsWithDetails = (pokemons = [])=> 
    async (dispatch)=> { 
        const pokemonsDetailed = await Promise.all(pokemons.map(pokemon => getPokemonDetail(pokemon)))
        dispatch(setPokemons(pokemonsDetailed))
    }
    Separaci√≥n de responsabilidades
      una vez creada el action creator lo importamos y podemos hacer 
      dispatch con el pas√°ndole como par√°metro nuestro arreglo de objetos 
      de pokemones
    
    src/App.js:

    const App = () => {
      const pokemons = useSelector(state => state.pokemons)
      const dispatch = useDispatch()


      useEffect(()=> {
        const fetchPokemons = async ()=> {
          const pokemonsRes = await getPokemon()
          dispatch(getPokemonsWithDetails(pokemonsRes)) // **
        }

        fetchPokemons()
      }, [])

      return (
        <div className="App">
          ....
        </div>
      );
    }